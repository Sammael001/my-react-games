{"version":3,"sources":["gothic-match-3/GemTile.js","gothic-match-3/WaterfallBoard.js","rune-flashcards/Tile.js","rune-flashcards/RuneBoard.js","vampire-concentration/Tile.js","vampire-concentration/VampBoard.js","App.js","index.js"],"names":["GemTile","classBuilder","value","props","paired","slide","className","this","onClick","myClick","Component","WaterfallBoard","state","board","createBoard","gotMatches","score","firstPick","secondPick","findMatches","gems","Math","floor","random","length","x","nCols","newCol","y","nRows","newGem","val","randGem","push","map","col","colIdx","colMap","elem","rowIdx","coord","key","gemClick","arr","firstVal","every","boardClone","cloneFactory","thisGem","triHori","checkEvery","setState","forEach","triVert","setTimeout","removeMatches","myScore","newClone","column","lastIdx","lastIndexOf","filteredCol","idx","filter","unshift","removeSliders","console","log","newMap","second","first","gem","getPermission","document","activeElement","blur","row","restart","renderBoard","defaultProps","Tile","rune","name","spanText","showHint","runeObj","Board","wonGame","startedGame","question","answer","message","runes","choice","myCaps","toUpperCase","runeMap","newQuest","menuClick","runeNames","startingMap","obj","newQs","myQuest","buildMenu","onStart","tileObj","reveal","img","tiles","Array","fill","startGame","i","myTiles","newArr","choices","j","objArr","handleClick","winner","tile","renderTile","App","currentGame","clickHandler","href","VampBoard","RuneBoard","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.3b6c49a4.chunk.js","sourcesContent":["import React, {Component} from 'react'\r\nimport \"./GemTile.css\";\r\n\r\nclass GemTile extends Component {\r\n\r\n  classBuilder = (value) => {\r\n    if (this.props.paired) {\r\n      return `tile bright ${value}-paired`;\r\n    } else if (this.props.slide) {\r\n      return `tile slider ${value}`;\r\n    } else {\r\n      return `tile ${value}`;\r\n    }\r\n\r\n  };\r\n\r\n  render() {\r\n\r\n    return (\r\n        <button\r\n          className={ this.classBuilder(this.props.value) }\r\n          onClick={ this.props.myClick }\r\n        >\r\n\r\n        </button>\r\n    )\r\n  }\r\n}\r\n\r\n\r\nexport default GemTile;\r\n\r\n// let myArr = [{name: \"a\", paired: false}, {name: \"b\", paired: false}, {name: \"c\", paired: true}, {name: \"d\", paired: false}];\r\n// const arrKeys = myArr.map(elem => elem.paired);\r\n// arrKeys.lastIndexOf(true); // 2\r\n// arrKeys.lastIndexOf(\"b\"); // -1 (not found)\r\n","import React, {Component} from \"react\";\r\nimport \"./WaterfallBoard.css\";\r\nimport GemTile from \"./GemTile\";\r\n\r\n// HERE IS HOW to work with clones of state without mutating state!!!\r\n// let row0map = this.state.row0.map(elem => ({...elem}));\r\n// note that we are BOTH mapping over the row array (to create row0map) AND using the spread operator to clone each element in that array\r\n\r\n// NOTE! calling this.findMatches() inside componentDidMount ensures that the function runs ONCE, as soon as the component loads/mounts:\r\n// componentDidMount() {\r\n//   this.findMatches();\r\n// }\r\n\r\n// The idea is to make the gem gameboard flow in the opposite direction: each COLUMN is an array of equal length, each ROW is the index in that column.\r\n//\r\n// This is how the board looks in this.state:\r\n// let board = [\r\n//   [ A, B, C ], // board[0]  <-- this # is our X-value, or our column value\r\n//   [ D, E, F ], // board[1]\r\n//   [ G, H, I ]  // board[2]\r\n// ];\r\n//\r\n// But this is how it is rendered on the page --- coordinates on the actual gameboard are X, Y (over, down)\r\n// A D G   ...   A = (X:0, Y:0)   |  D = (X:1, Y:0)   |  G = (X:2, Y:0)\r\n// B E H   ...   B = board[0][1]  |  E = board[1][1]  |  F = board[2][1]\r\n// C F I   ...   C = board[0][2]  |  F = board[1][2]  |  I = board[2][2]\r\n//\r\n//\r\n// ** With this arrangement, we can use simple array methods to delete gems with paired: true from each column, and shift down the gems above, and push new gems to the beginning of each array\r\n//\r\n// Checking for matches should be the same; we can loop through the nested arrays and...\r\n// ...for HORIZONTAL - check if thisGem.val matches the values of board[x+1][y] and board[x+2][y]\r\n// ...for VERTICAL - check if thisGem.val matches the values of board[x][y+1] and board[x][y+2]\r\n\r\n\r\nclass WaterfallBoard extends Component {\r\n\r\n  static defaultProps = {\r\n    nRows: 8,\r\n    nCols: 8,\r\n    gems: [\"ankh2\", \"bat\", \"coffin\", \"eye\", \"emerald\", \"skull\", \"moon2\", \"goblet\" ]\r\n  };\r\n  // ^^ the dimensions of the WaterfallBoard\r\n\r\n  constructor(props){\r\n    super(props);\r\n    this.state = {\r\n      board: this.createBoard(),\r\n      gotMatches: false,\r\n      score: 0,\r\n      firstPick: null,\r\n      secondPick: null\r\n    };\r\n  }\r\n\r\n\r\n  // ** This is a a working copy, with sliders!! **\r\n\r\n\r\n  // calling this.findMatches() inside componentDidMount ensures that the function runs ONCE, as soon as the component loads/mounts\r\n  componentDidMount() {\r\n    this.findMatches();\r\n  }\r\n\r\n  // helper method to return a random gem\r\n  randGem(){\r\n    const { gems } = this.props;\r\n    return gems[Math.floor(Math.random() * gems.length)];\r\n  }\r\n\r\n  // called inside this.state to create the board itself\r\n  // createBoard gives the initial row/col values to each gem\r\n  createBoard(){\r\n    // console.log(\"Creating the board...\");\r\n    let board = [];\r\n    for (let x = 0; x < this.props.nCols; x++) { // outer loop to create each COLUMN\r\n      let newCol = [];\r\n      for (let y = 0; y < this.props.nRows; y++) { // inner loop to create each ROW\r\n        let newGem = {}; // for each element, init empty object\r\n        newGem.val = this.randGem(); // return random gem value from this.props.gems\r\n        newGem.x = x; // set the column index as the value of \"x\"\r\n        newGem.y = y; // set the row index as the value of \"y\"\r\n        newGem.paired = false; // init the .paired property as \"false\"\r\n        newGem.slide = false; // (A) init gems with slide = false\r\n        newCol.push(newGem); // push each newGem into the row\r\n      }\r\n      board.push(newCol); // push each newRow into the board\r\n    }\r\n    return board;\r\n  }\r\n\r\n  // renders the board inside <WaterfallBoard/>'s return()\r\n  renderBoard(){\r\n    // map over this.state.board, getting each \"column\" array and the index of that column\r\n    let boardMap = this.state.board.map((col, colIdx) => {\r\n      // then map over the row, getting each element and its index\r\n      let colMap = col.map((elem, rowIdx) => {\r\n        let coord = `${colIdx}-${rowIdx}`;\r\n        return (\r\n          <GemTile\r\n            key = {coord}\r\n            value = {elem.val}\r\n            x = {colIdx}\r\n            y = {rowIdx}\r\n            paired = {elem.paired}\r\n            slide = {elem.slide} // (B) pass slide prop to GemTile\r\n            myClick = { () => this.gemClick(elem, coord) }\r\n          />\r\n        )\r\n      });\r\n      // for each row, return a <div> element which contains each colMap\r\n      // make sure that .board-col displays VERTICALLY on the page\r\n      return <div className=\"board-col\" key={colIdx}>{colMap}</div>\r\n    });\r\n    return boardMap;\r\n  }\r\n\r\n  // helper func to generate clone of board\r\n  cloneFactory(){\r\n    const boardClone = this.state.board.map(col => {\r\n       return col.map(elem => {\r\n         return {...elem}; // note that we're using spread operator to clone each element in each row\r\n       });\r\n     });\r\n     return boardClone;\r\n  }\r\n\r\n  // helper func that checks if every element in an array has the same value as the first element\r\n  checkEvery(arr){\r\n    let firstVal = arr[0].val;\r\n    return arr.every(elem => elem.val === firstVal);\r\n  }\r\n\r\n  // findMatches -- function that detects matches on the board and deletes them\r\n  findMatches() {\r\n    const {firstPick, secondPick} = this.state;\r\n    // console.log(\"running findMatches()...\");\r\n    const boardClone = this.cloneFactory();\r\n    // we ONLY need to check if the 2 gems ahead, or 2 gems below, are the same value as the current gem -- if so, set these 3 to receive paired: true\r\n    // this will result in some gems being paired multiple times, but this doesn't matter\r\n\r\n    // outer loop gives the X-value of each column (remember, each column is an array)\r\n    for (let x = 0; x < boardClone.length; x++) {\r\n      // inner loop goes through each element, giving the Y-value\r\n      for (let y = 0; y < boardClone[x].length; y++) {\r\n        // set the value of the current (x,y) position as thisGem.. remember, these gems are OBJECTS\r\n        let thisGem = boardClone[x][y];\r\n\r\n        // checking for horizontal matches\r\n        // we must check to make sure we're not setting hori2 or hori3 equal to a non-existent set of coordinates\r\n        // doing so will throw an error \"cannot read property '0' of undefined\"\r\n        if (x < boardClone.length - 2) {\r\n          // setting elements in 2 adjacent cols as hori2 and hori3\r\n          let hori2 = boardClone[x + 1][y];\r\n          let hori3 = boardClone[x + 2][y];\r\n          let triHori = [thisGem, hori2, hori3];\r\n          // passing all 3 gems into checkEvery helper func\r\n          if (this.checkEvery(triHori)) {\r\n            // if checkEvery returns true, set the state flag 'gotMatches'...\r\n            this.setState({ gotMatches: true });\r\n            // ...and set every element with coordinates of those 3 gems to paired=true\r\n            triHori.forEach(elem => {\r\n              boardClone[elem.x][elem.y].paired = true;\r\n            })\r\n          }\r\n        }\r\n\r\n        // checking for vertical matches\r\n        if (y < boardClone[x].length - 2) {\r\n          let vert2 = boardClone[x][y + 1];\r\n          let vert3 = boardClone[x][y + 2];\r\n          let triVert = [thisGem, vert2, vert3];\r\n          if (this.checkEvery(triVert)) {\r\n            this.setState({ gotMatches: true });\r\n            triVert.forEach(elem => {\r\n              boardClone[elem.x][elem.y].paired = true;\r\n            })\r\n          }\r\n        }\r\n\r\n      } // end of inner FOR loop\r\n    } // end of outer FOR loop\r\n\r\n    // setState with the boardClone we've modified, which may contain paired elements\r\n    this.setState({ board: boardClone });\r\n    // if paired elements exist, call removeMatches to eliminate paired elements\r\n    setTimeout(() => {\r\n      if (this.state.gotMatches){\r\n        // console.log(\"We have matches, let's call removeMatches()\");\r\n        this.removeMatches();\r\n      } else {\r\n        // console.log(\"No matches, don't bother calling removeMatches()\");\r\n        if (firstPick && secondPick) {\r\n          // console.log(\"toggling 2 tiles back to original values\");\r\n          // firstPick and secondPick identify which tiles were switched, and their original values\r\n          // ..so placing firstPick.val into boardClone[firstPick.x][firstPick.y] reverses the changes from gemClick\r\n          boardClone[firstPick.x][firstPick.y].val = firstPick.val;\r\n          boardClone[secondPick.x][secondPick.y].val = secondPick.val;\r\n          setTimeout(() => {\r\n            // setting firstPick + secondPick back to null\r\n            this.setState({ firstPick: null, secondPick: null, board: boardClone });\r\n          }, 500);\r\n        }\r\n      }\r\n    }, 500);\r\n\r\n\r\n  } // end of findMatches\r\n\r\n  // method to delete matches and shift gems above the match, downward\r\n  removeMatches(){\r\n    // console.log(\"removeMatches() was called\");\r\n    let myScore = this.state.score;\r\n    // let {firstPick, secondPick} = this.state;\r\n     // clone the board\r\n    const boardClone = this.cloneFactory();\r\n\r\n    // loop through the board and tally all paired gems to get the score\r\n    boardClone.forEach(col => {\r\n      col.forEach(elem => {\r\n        if (elem.paired) {\r\n          myScore += 10;\r\n        }\r\n      })\r\n    });\r\n\r\n    // this timeout waits 1 second before removing matches\r\n    setTimeout(() => {\r\n      // console.log(\"...removing paired gems...\");\r\n\r\n      // creating a newClone of the board...\r\n      const newClone = boardClone.map((column, colIdx) => {\r\n        // for each column, we need to locate the LAST paired element\r\n\r\n        // generate an array of all paired values in the column\r\n        const lastPaired = column.map(elem => elem.paired);\r\n\r\n        // get index of LAST paired element in the array\r\n        let lastIdx = lastPaired.lastIndexOf(true);\r\n        // console.log(lastIdx);\r\n\r\n        // map over column and set every element whose index is LESS than lastIdx to slide=TRUE\r\n        const toSlide = column.map((elem, idx) => {\r\n          let newGem = {...elem}\r\n          if (lastIdx !== -1 && idx < lastIdx) {\r\n            newGem.slide = true;\r\n          }\r\n         return newGem;\r\n        });\r\n\r\n        // ... then take each column and filter it to only contain unpaired gems\r\n        const filteredCol = toSlide.filter(elem => elem.paired === false);\r\n\r\n        // const filteredCol = column.filter(elem => elem.paired === false);\r\n        // this shortens the col-arrays, so while the filtered arrays are shorter than their original length...\r\n        while (filteredCol.length < column.length) {\r\n          // ...create new gems\r\n          let newGem = {};\r\n          // ** TODO: figure out how to add an animation class here that makes these gems slide down\r\n          newGem.x = colIdx;\r\n          newGem.val = this.randGem();\r\n          newGem.paired = false;\r\n          newGem.slide = true; // as we're filling board with new gems after removing pairs, add gems with slide = true\r\n          // ..and push the new gems to the FRONT of the filtered arrays\r\n          filteredCol.unshift(newGem);\r\n        }\r\n        // once we've refilled the filtered, correct-length arrays, map over them to give the array index as y-value to each element\r\n        let filterMap = filteredCol.map((elem, rowIdx) => {\r\n          let newGem = {...elem};\r\n          newGem.y = rowIdx;\r\n          return newGem;\r\n        });\r\n        // return the new filtered, correct-length array full of gems that have proper X and Y values\r\n        return filterMap; // <-- this is what gets returned from filterMap\r\n      });\r\n\r\n      // set the gotMatches flag back to false\r\n      this.setState({ gotMatches: false });\r\n\r\n      // replace the board with our updated one, newClone\r\n      this.setState({ board: newClone, score: myScore, firstPick: null, secondPick: null });\r\n\r\n      // call this.removeSliders to take away sliding gems\r\n      this.removeSliders();\r\n\r\n      // * if findMatches locates no matches on the 2nd iteration, we wind up inside the IF() block above\r\n    }, 1000);\r\n\r\n  } // end of removeMatches\r\n\r\n\r\n  // call removeSliders from the final block of this.removeMatches\r\n  removeSliders(){\r\n    console.log(\"removeSliders()\");\r\n    const boardClone = this.cloneFactory();\r\n    let newMap = boardClone.map(col => {\r\n      return col.map(elem => {\r\n        let newGem = {...elem};\r\n        newGem.slide = false;\r\n        return newGem;\r\n      });\r\n    });\r\n    // timeout to ensure board is updated before removing sliders\r\n    setTimeout(()=>{\r\n      this.setState({ board: newMap });\r\n      // call this.findMatches again to see if removeMatches made any new matches\r\n      this.findMatches();\r\n    }, 1000);\r\n\r\n  }\r\n\r\n\r\n\r\n  // helper func to check if firstPick and prospective secondPick are neighbors\r\n  getPermission(second){\r\n    let first = this.state.firstPick;\r\n    if (first.x === second.x) { // in the same column\r\n      if (first.y === second.y-1 || first.y === second.y+1) { // and on the row below, or row above\r\n        return true;\r\n      }\r\n    } else if (first.y === second.y) { // in the same row\r\n      if (first.x === second.x+1 || first.x === second.x-1) { // and either on the col ahead, or col behind\r\n        return true;\r\n      }\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // function that handles clicks on each tile\r\n  gemClick(gem){\r\n    // console.log(gem);\r\n    const {firstPick, secondPick} = this.state;\r\n    if (!firstPick) {\r\n      this.setState({ firstPick: gem });\r\n    } else if (firstPick && secondPick) {\r\n      // FIXED BUG: this resolves an issue where picking a third gem would reset the value of the second\r\n      console.log(\"Can't pick more than 2 gems\");\r\n      return;\r\n    } else if (!this.getPermission(gem)) {\r\n      console.log(\"forbidden match\");\r\n      this.setState({ firstPick: null });\r\n      // remove focus from the element after 500ms\r\n      setTimeout(()=>{ document.activeElement.blur(); }, 500);\r\n    } else if (this.getPermission(gem)) {\r\n      console.log(\"permitted match\");\r\n      // remove focus from the element after 500ms...which is when findMatches begins to run\r\n      setTimeout(()=>{ document.activeElement.blur(); }, 500);\r\n      // clone the board\r\n      const boardClone = this.state.board.map(row => {\r\n        return row.map(elem => {\r\n          return {...elem}; // note that we're using spread operator to clone each element in each row\r\n        });\r\n      });\r\n      boardClone[firstPick.x][firstPick.y].val = gem.val; // set the current gem (secondPick) val, as the val of the gem at boardClone[firstPick.x][firstPick.y] ...\r\n      boardClone[gem.x][gem.y].val = firstPick.val; // ...and vice-versa for current gem (secondPick)\r\n      // note that we are not changing values of firstPick and secondPick here!\r\n      this.setState({ board: boardClone, secondPick: gem });\r\n      setTimeout(() => {\r\n        console.log(`FirstPick value: ${firstPick.val}`);\r\n        console.log(`SecondPick value: ${gem.val}`);\r\n        this.findMatches(); // run findMatches() again\r\n      }, 500);\r\n\r\n    }\r\n  }\r\n\r\n  // function to reload game board and rerun findMatches()\r\n  restart(){\r\n    console.log(\"restarting game...\");\r\n    this.setState({ board: this.createBoard(), score: 0 });\r\n    // wait for the board creation to run findMatches\r\n    setTimeout(() => {\r\n      this.findMatches();\r\n      document.activeElement.blur();\r\n    }, 500);\r\n  }\r\n\r\n\r\n\r\n  render(){\r\n\r\n    return(\r\n        <div className=\"board-container\">\r\n\r\n          <div className=\"board-title\">\r\n            <h1 className=\"title\">Gothic Match-3</h1>\r\n            <h3 className=\"score\">Score: {this.state.score}</h3>\r\n            <button className=\"restart\" onClick={ ()=>{this.restart()} }>Restart Game</button>\r\n          </div>\r\n          <div className=\"board-game\">\r\n            { this.renderBoard() }\r\n          </div>\r\n\r\n        </div>\r\n      )\r\n\r\n  }\r\n\r\n};\r\n\r\nexport default WaterfallBoard;\r\n","import React, {Component} from \"react\";\r\nimport \"./Tile.css\";\r\n\r\nclass Tile extends Component {\r\n\r\n  classBuilder = (rune) => {\r\n    if (rune.paired) {\r\n      return `default-button rune-tile paired ${rune.name}-paired`;\r\n    } else {\r\n      return `default-button rune-tile unpaired ${rune.name}`;\r\n    }\r\n  }\r\n\r\n  spanText = (rune) => {\r\n    if (rune.paired || this.props.showHint) {\r\n      return rune.name;\r\n    } else {\r\n      return \"\";\r\n    }\r\n  }\r\n\r\n  // methods go here\r\n  render(){\r\n    return(\r\n      <div>\r\n        <button\r\n          onClick = { () => {this.props.onClick()} }\r\n          className = { this.classBuilder(this.props.runeObj) }\r\n        >\r\n          <span className=\"rune-name-span\">\r\n            { this.spanText(this.props.runeObj) }\r\n          </span>\r\n\r\n        </button>\r\n      </div>\r\n    )\r\n  }\r\n};\r\n\r\nexport default Tile;\r\n\r\n// { this.props.runeObj.paired\r\n//   ? this.props.runeObj.name\r\n//   : null\r\n// }\r\n","import React, {Component} from \"react\";\r\nimport \"./Board.css\";\r\nimport Tile from \"./Tile\";\r\n\r\n\r\n\r\nclass Board extends Component {\r\n\r\n  static defaultProps = {\r\n    runeNames: [ \"fehu\",  \"uruz\", \"thurisaz\", \"ansuz\", \"raidho\", \"kaunaz\", \"gebo\", \"wunju\", \"hagalaz\", \"naudiz\", \"isa\", \"jara\", \"eihwaz\", \"perthu\", \"algiz\", \"sowulo\", \"teiwaz\", \"berkana\", \"ehwaz\", \"mannaz\", \"laguz\", \"ingwaz\", \"dagaz\", \"othala\"]\r\n  };\r\n\r\n  constructor(props){\r\n    super(props);\r\n    this.state = {\r\n      wonGame: false,\r\n      startedGame: false,\r\n      showHint: false,\r\n      question: \"\",\r\n      answer: \"\",\r\n      message: \"Click the start button to begin\",\r\n      runes: []\r\n    }\r\n  };\r\n\r\n  // click handler for each rune tile\r\n  menuClick(choice) {\r\n    const { question, runes } = this.state;\r\n    console.log(`Clicked on ${choice}`);\r\n    this.setState({ answer: choice });\r\n    let myCaps = choice.toUpperCase();\r\n\r\n    // if you guessed correctly...\r\n    if (question === choice) {\r\n      console.log(`Matched ${question} and ${choice}`);\r\n      this.setState({ message: `That's right! This is the rune ${myCaps}` })\r\n      // if we got a match, map over this.state.runes\r\n      let runeMap = runes.map(rune => {\r\n        if (rune.name === choice) {\r\n          return {...rune, paired: true}; // set rune.paired to TRUE if the rune.name matches the question\r\n        } else {\r\n          return rune; // otherwise, return the rune without changes\r\n        }\r\n      });\r\n      this.setState({ runes: runeMap }); // set this.state.runes to the new map\r\n      setTimeout(() => {\r\n        console.log(\"Timeout reached, clearing answer + getting new question\");\r\n        this.setState({ answer: \"\", message: \"\" });\r\n        this.newQuest(); // this will generate a new question\r\n      }, 3000);\r\n    } else { // else, if you guessed incorrectly\r\n      this.setState({ message: `Wrong, this is the rune ${myCaps}` });\r\n      setTimeout(() => {\r\n        console.log(\"Timeout reached, clearing answer\");\r\n        this.setState({ answer: \"\", message: \"\" });\r\n      }, 3000);\r\n    }\r\n  }\r\n\r\n  // creating runes-menu\r\n  buildMenu() {\r\n    // hide the menu buttons if the game hasn't started yet...this is redundant, since we don't call this.buildMenu inside the <Board>'s return() if startedGame is false\r\n    if (this.state.startedGame) {\r\n      // map over this.state.runes to create runes-menu\r\n      // pass in rune obj to each Tile that contains runeName and paired props\r\n      // in Tile.js, use the 'paired' prop to highlight menu runes in gold, and show rune name, once they've been properly paired\r\n      let runeMap = this.state.runes.map((rune, idx) => {\r\n        return(\r\n          <Tile\r\n            key = { idx }\r\n            runeObj = { rune }\r\n            onClick = { () => {this.menuClick(rune.name)} }\r\n            showHint = { this.state.showHint }\r\n          />\r\n        )\r\n      });\r\n      return runeMap;\r\n    } else {\r\n      return null\r\n    }\r\n  }\r\n\r\n  // button that initializes the game (also restarts the game)\r\n  onStart() {\r\n    const {runeNames} = this.props;\r\n    // set startedGame to true, which hides the Start button and reveals the rune-menu\r\n    this.setState({ startedGame: true });\r\n    // pull from defaultProps.runenames and create 24 objects, each with a runeName and a paired property (init paired as false)\r\n    let startingMap = runeNames.map(rune => {\r\n      let obj = {};\r\n      obj.name = rune;\r\n      obj.paired = false;\r\n      return obj;\r\n    });\r\n    console.log(startingMap);\r\n    // pick a random rune from the startingMap to give the first question\r\n    let rand = Math.floor(Math.random() * startingMap.length);\r\n    let question = startingMap[rand].name;\r\n    // store the new rune obj array, startingMap, in this.state.runes\r\n    this.setState({ question: question, message: \"\", runes: startingMap });\r\n  }\r\n\r\n  // generates a new random rune as a question\r\n  newQuest() {\r\n    // loop through this.state.runes\r\n    const { runes } = this.state;\r\n    let newQs = runes.filter(rune => {\r\n      // return list of only the unpaired runes\r\n      return rune.paired === false;\r\n    });\r\n    console.log(newQs);\r\n    // check to see if newQs.length === 0, and if so, set this.state.wonGame to TRUE\r\n    if (newQs.length === 0) {\r\n      this.setState({ message: \"Congrats, you've named all the runes!\", wonGame: true, startedGame: false })\r\n      // set startedGame back to false to show the Start/Replay button and hide the rune-menu\r\n    } else {\r\n      // else, generate new question from this new list of unpaired runes\r\n      let rand = Math.floor(Math.random() * newQs.length);\r\n      let question = newQs[rand].name;\r\n      this.setState({ question: question });\r\n    }\r\n  }\r\n\r\n  // shows the names of all the runes for a few seconds\r\n  showHint() {\r\n    this.setState({ showHint: true });\r\n    console.log(\"Showing hints\");\r\n    setTimeout(() => {\r\n      this.setState({ showHint: false });\r\n      console.log(\"Hiding hints\");\r\n    }, 5000);\r\n  }\r\n\r\n  render(){\r\n    const { question, message, startedGame, wonGame } = this.state;\r\n    const myQuest = question.toUpperCase();\r\n    // <div className=\"question-box\"> either shows this.state.message or, if that is blank, directs you to find the next rune\r\n    // <div className=\"rune-box\"> calls this.buildMenu if this.state.startedGame is true; otherwise it returns null\r\n    // the start button only shows if startedGame is FALSE\r\n    return(\r\n      <div className=\"container\">\r\n        <h1 className=\"title\">Rune Flashcards</h1>\r\n\r\n        <div className=\"question-box\">\r\n          <h2 className=\"message\">\r\n            { message.length !== 0\r\n              ? message\r\n              : `Find this rune: ${myQuest}`\r\n            }\r\n          </h2>\r\n        </div>\r\n\r\n        { startedGame\r\n          ? (\r\n            <div className=\"rune-box\">\r\n              { this.buildMenu() }\r\n            </div>\r\n          )\r\n          : null\r\n        }\r\n\r\n\r\n        { startedGame\r\n          ? null\r\n          : (\r\n            <button onClick={ ()=>{ this.onStart() } } className=\"start-button default-button\">\r\n              { wonGame ? \"Replay\" : \"Start\" }\r\n            </button>\r\n          )\r\n        }\r\n\r\n        { startedGame\r\n          ? (\r\n            <button className=\"start-button default-button\" onClick={ ()=>{ this.showHint() } }>\r\n              Show Rune Names\r\n            </button>\r\n          )\r\n          : null\r\n        }\r\n      </div>\r\n    )\r\n  }\r\n};\r\n\r\nexport default Board;\r\n","import React, { Component } from \"react\";\r\nimport \"./Tile.css\";\r\n\r\n\r\nclass Tile extends Component {\r\n  // onClick attribute is just a cb which calls the func passed in via the onClick prop\r\n  classBuilder = (tileObj) => {\r\n    if (tileObj.reveal === \"hide\") { return `Tile-button hilight bg`; }\r\n    if (tileObj.reveal === \"paired\" ) { return `Tile-button ${tileObj.img}-fade`; }\r\n    if (tileObj.reveal === \"show\" ) { return `Tile-button hilight ${tileObj.img}`; }\r\n    // return a string here, which reads like so: \"Tile-button ankh-fade\"\r\n    // call this function inside className bracket below\r\n  }\r\n\r\n  render(){\r\n    // style={ { backgroundColor: tileObj.img } }\r\n    // style={ { backgroundImage: `url(./vamp-imgs/${tileObj.img}.jpg)` } }\r\n    const { tileObj } = this.props;\r\n\r\n    return(\r\n      <div className=\"Tile\">\r\n        { tileObj\r\n          ? <button\r\n              className={ this.classBuilder(tileObj) }\r\n              onClick={() => { this.props.onClick() }}\r\n            >\r\n            </button>\r\n          : <button className=\"Tile-button bg-fade\"></button>\r\n        }\r\n      </div>\r\n    )\r\n  }\r\n};\r\n\r\n// before we click startGame, tileObj is not even an object, but a null value\r\n// therefore we use ternary operator to render either a plain button, or button with tileObj.img and tileObj.reveal values\r\n\r\n\r\n// <button\r\n//    className={`Tile-button ${tileObj.img}`}\r\n//    onClick={() => { this.props.onClick() }}\r\n//  >\r\n\r\nexport default Tile;\r\n","import React, {Component} from \"react\";\r\nimport \"./Board.css\";\r\nimport Tile from \"./Tile\";\r\n\r\nclass Board extends Component {\r\n\r\n  static defaultProps = {\r\n    choices: [\"fangs2\", \"ankh\", \"moon\", \"blood\", \"castle\", \"candles2\", \"cup\", \"bats\"]\r\n  };\r\n\r\n  constructor(props){\r\n    super(props);\r\n    this.state = {\r\n      tiles: Array(16).fill(null),\r\n      startGame: false,\r\n      firstPick: null,\r\n      secondPick: null,\r\n    };\r\n  }\r\n\r\n\r\n  handleClick(i){\r\n    // each tile has their own copy of handleClick, with their index position in this.state.tiles as \"i\"\r\n    const { firstPick, secondPick, tiles } = this.state;\r\n    let newCol = tiles[i]; // this is an obj like so: {img: \"fangs\", reveal: \"hide\"}\r\n    if (newCol.reveal !== \"hide\" ) { return; } // return early if we've clicked on a tile that's already shown or paired\r\n    if ( firstPick && secondPick ) { return; } // return early if we've already got firstPick and secondPick defined\r\n    // ^^ only happens when they're both mismatched and we're waiting for setTimeout to hide them again\r\n    if (!firstPick) { // if there's nothing in firstPick...\r\n      newCol.reveal = \"show\"; // reveal the tile\r\n      this.setState({ firstPick: newCol }); // use that tile to define firstPick\r\n\r\n    } else { // else, there's already a value in firstPick\r\n\r\n      if (firstPick.img === newCol.img) { // if we have a match...\r\n        console.log(`${firstPick.img} and ${newCol.img} -- yay, a match!`);\r\n        // update these elements in this.state.tiles to have class \"paired\"\r\n        const myTiles = tiles.map(obj => { // map over this.state.tiles\r\n          if (obj.img === newCol.img) { // find tile objs whose img matches newCol.img\r\n            return { ...obj, reveal: \"paired\" };  // <-- return clone of the obj, but with reveal set to \"paired\"\r\n          } else { return obj; } // <-- else just return the obj intact\r\n        });\r\n        this.setState({ firstPick: null, tiles: myTiles }); // set firstPick back to 'null' and update this.state.tiles with the result of the map() above\r\n\r\n      } else { // else, we have NO match\r\n        console.log(`${firstPick.img} and ${newCol.img} -- no match :(`);\r\n        newCol.reveal = \"show\"; // show the non-matching selection\r\n        this.setState({ secondPick: newCol }); // update state with secondPick for a moment, so the components rerender\r\n        setTimeout(() => { // use setTimeout to delay long enough for user to see the non-matching pair\r\n          const myTiles = tiles.map(obj => { // then map over myTiles to hide all tiles with reveal: \"show\"\r\n            if (obj.reveal === \"show\") {\r\n              return { ...obj, reveal: \"hide\" };  // <-- return clone of the obj, but with reveal set to \"hide\"\r\n            }\r\n            else { return obj; } // <-- else just return the obj intact\r\n          })\r\n          this.setState({ firstPick: null, secondPick: null, tiles: myTiles }); // reset firstPick + secondPick and reset the game board, now with non-paired tiles hidden\r\n          console.log(\"timer up!\");\r\n        }, 1500);\r\n      }\r\n\r\n  }}\r\n\r\n  startGame(){\r\n    this.setState({ startGame: true });\r\n    let newArr = []; // init new empty array to hold our game tiles\r\n    let idx = 0;\r\n    // first, generate tile-picture pairs and push them sequentially into newArr\r\n\r\n    // while newArr is shorter than this.state.tiles.length ... (checking idx is not really needed)\r\n    while (newArr.length < this.state.tiles.length && idx < this.props.choices.length) {\r\n      let newCol = this.props.choices[idx]; // get tile-picture at index [idx] from choices\r\n      newArr.push(newCol, newCol); // push pair of tile-pictures into newArr\r\n      idx++; // increment the index\r\n    }\r\n    console.log(\"Exited loop: \", newArr);\r\n\r\n    // then, scramble order of newArr -- see https://stackoverflow.com/a/12646864\r\n    for (let i = newArr.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [newArr[i], newArr[j]] = [newArr[j], newArr[i]];\r\n    }\r\n    console.log(\"Scrambled newArr: \", newArr);\r\n    // now we have randomly distributed pairs of tile-pictures in our 3D array, newArr\r\n    // next, set objArr to the result of mapping over newArr and creating array of objs\r\n    // use each element value in newArr as \"img\" prop (these are the tile-pic names), and set a \"reveal\" prop of \"hide\" on each obj\r\n    const objArr = newArr.map(elem => {\r\n      let obj = {};\r\n      obj.img = elem;\r\n      obj.reveal = \"hide\";\r\n      return obj;\r\n    });\r\n    console.log(objArr);\r\n    // setState with objArr replacing this.state.tiles\r\n    this.setState({ tiles: objArr });\r\n  }\r\n\r\n  renderTile(i){\r\n    // func that creates our Tile components ...\r\n    // (we pass the \"i\" arg to each renderTile call manually, inside the render() method of Board)\r\n    // renderTile takes in \"i\" and sets Tile's tileObj prop to whatever is at this.state.tiles at index \"i\"\r\n    // also sets onClick prop as a reference to this.handleClick() here in Board, and passes \"i\" to that func\r\n    return(\r\n      <Tile\r\n        tileObj={this.state.tiles[i]}\r\n        onClick={() => {this.handleClick(i)}}\r\n      />\r\n    )\r\n  }\r\n\r\n  onStart(){\r\n    let winner = false; // init \"winner\" var to false\r\n    if (this.state.tiles[0]){ // if there's a null value in this.state.tiles[0], the game has not begun yet\r\n      winner = this.state.tiles.every(tile => { // let winner equal TRUE if every tile in this.state.tiles has reveal=\"paired\"\r\n        return tile.reveal === \"paired\";\r\n      });\r\n    }\r\n    if (!this.state.startGame) { // if the game hasn't started yet..\r\n      return 'Board-start-visible'; // ..return a class that adds a red overlay + positions Start button at top\r\n    } else if (winner) { // checking for the winner var we set above\r\n      console.log(\"Winner is true\");\r\n      return 'Board-start-visible'; // of if the game has been won, add the same class as above\r\n    } else {\r\n      return 'Board-start';\r\n    }\r\n  }\r\n\r\n  render(){\r\n\r\n    let winner = false;\r\n    function checkWinner(tile){\r\n      return tile.reveal === \"paired\"; // checkWinner returns TRUE if every tile it receives has reveal=\"paired\"\r\n    }\r\n    if (this.state.tiles[0]) { // if there's a null value in this.state.tiles[0], the game has not begun yet\r\n      winner = this.state.tiles.every(checkWinner); // set winner to TRUE if checkWinner returns TRUE when checking every tile\r\n      console.log(`Winner is ${winner}`);\r\n    }\r\n\r\n    return(\r\n      <div className=\"Board\">\r\n        <h1 className=\"Board-title\">Vampire Memory</h1>\r\n        <div className=\"Board-row\">\r\n          {this.renderTile(0)}\r\n          {this.renderTile(1)}\r\n          {this.renderTile(2)}\r\n          {this.renderTile(3)}\r\n        </div>\r\n        <div className=\"Board-row\">\r\n          {this.renderTile(4)}\r\n          {this.renderTile(5)}\r\n          {this.renderTile(6)}\r\n          {this.renderTile(7)}\r\n        </div>\r\n        <div className=\"Board-row\">\r\n          {this.renderTile(8)}\r\n          {this.renderTile(9)}\r\n          {this.renderTile(10)}\r\n          {this.renderTile(11)}\r\n        </div>\r\n        <div className=\"Board-row\">\r\n          {this.renderTile(12)}\r\n          {this.renderTile(13)}\r\n          {this.renderTile(14)}\r\n          {this.renderTile(15)}\r\n        </div>\r\n        <div className= { this.onStart() } >\r\n          { winner ? <h1>You Win! Play again?</h1> : null }\r\n          <button className=\"Board-start-button\" onClick={ () => this.startGame() }>Start Game</button>\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default Board;\r\n","import React, {Component} from 'react';\nimport './App.css';\n\nimport WaterfallBoard from \"./gothic-match-3/WaterfallBoard\";\nimport RuneBoard from \"./rune-flashcards/RuneBoard\";\nimport VampBoard from \"./vampire-concentration/VampBoard\";\n\nclass App extends Component{\n  constructor(props){\n    super(props);\n    this.state = {\n      currentGame: \"default\"\n    }\n  }\n\n  clickHandler(key){\n    this.setState({ currentGame: key });\n  }\n\n  render(){\n    return(\n      <div>\n        <div className={ this.state.currentGame === \"default\" ? \"nav-full\" : \"nav-menu\" }>\n          <h1>my React games</h1>\n          <div className=\"nav-box\">\n            <button className=\"nav-button match-button\" onClick={() => {this.clickHandler(\"goth\")}}>Gothic Match-3</button>\n            <button className=\"nav-button vamp-button\" onClick={() => {this.clickHandler(\"vamp\")}}>Vampire Memory</button>\n            <button className=\"nav-button rune-button\" onClick={() => {this.clickHandler(\"rune\")}}>Rune Flashcards</button>\n            <a href=\"https://sammael001.github.io/new-public-portfolio/\"><button className=\"nav-button portfolio\">Back to Portfolio</button></a>\n          </div>\n        </div>\n        <div className=\"game-container\">\n          { this.state.currentGame === \"goth\"\n            ? <WaterfallBoard />\n            : null\n          }\n          { this.state.currentGame === \"vamp\"\n            ? <VampBoard />\n            : null\n          }\n          { this.state.currentGame === \"rune\"\n            ? <RuneBoard />\n            : null\n          }\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}